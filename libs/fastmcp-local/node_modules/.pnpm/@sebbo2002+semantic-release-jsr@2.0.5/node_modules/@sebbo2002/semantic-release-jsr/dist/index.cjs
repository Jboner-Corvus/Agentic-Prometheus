"use strict";var P=Object.defineProperty;var S=Object.getOwnPropertyDescriptor;var k=Object.getOwnPropertyNames;var V=Object.prototype.hasOwnProperty;var z=(e,o)=>{for(var n in o)P(e,n,{get:o[n],enumerable:!0})},B=(e,o,n,s)=>{if(o&&typeof o=="object"||typeof o=="function")for(let r of k(o))!V.call(e,r)&&r!==n&&P(e,r,{get:()=>o[r],enumerable:!(s=S(o,r))||s.enumerable});return e};var D=e=>B(P({},"__esModule",{value:!0}),e);var O={};z(O,{fail:()=>$,generatePublishResponse:()=>d,getTemporaryBinFolder:()=>C,jsrPublish:()=>f,parseConfig:()=>l,prepare:()=>v,publish:()=>J,removeTemporaryBinFolder:()=>g,success:()=>j,updateVersionJson:()=>h,verifyConditions:()=>R});module.exports=D(O);var w=require("jsr"),x=require("os"),u=require("path"),t=require("fs"),i=require("fs/promises");async function l(e){let o=e.cwd||process.cwd(),n=e.pkgJsonPath||(0,u.join)(o,"package.json");!e.pkgJsonPath&&!(0,t.existsSync)(n)&&(n=null);let s,r=[],m=(0,u.join)(o,"jsr.json"),p=(0,u.join)(o,"deno.json");(0,t.existsSync)(m)&&r.push(m),(0,t.existsSync)(p)&&r.push(p),n&&r.push(n);for(let N of r){let F=await(0,i.readFile)(N,"utf8"),b=JSON.parse(F);!s&&b.name&&(s=b.name)}if(!s)throw new Error("No name found in jsr.json or deno.json");let c=e.publishArgs?.slice(0)||[];return(e.allowDirty===void 0||e.allowDirty)&&!c.includes("--allow-dirty")&&c.push("--allow-dirty"),{cwd:o,name:s,prepare:{versionJsonPaths:r},publish:{binFolder:C(),canary:!1,pkgJsonPath:n,publishArgs:c}}}var a;function C(){if(a)return a;let e=(0,t.mkdtempSync)((0,u.join)((0,x.tmpdir)(),"semantic-release-jsr-"));return a=e,e}async function g(){a&&(await(0,i.rm)(a,{recursive:!0,force:!0}),a=void 0)}async function h(e,o){if(!o.nextRelease)return;o.logger.log(`Updating version in ${e}`);let n=o.nextRelease.version,s=await(0,i.readFile)(e,"utf8");if(JSON.parse(s).version===n){o.logger.log(`Skipped, ${e} is already up to date`);return}let m=/^([\s\S]*"version"\s*:\s*")([^"]+)("[\s\S]*$)/,p=s.replace(m,`$1${n}$3`);if(JSON.parse(p).version!==n)throw new Error(`Failed to replace version in ${e}`);await(0,i.writeFile)(e,p,"utf8"),o.logger.log(`Wrote new version to ${e}`)}async function f(e,o){o.logger.log(`Run jsr publish in ${e.cwd} with ${JSON.stringify(e.publish)}`);let n=Date.now();try{await(0,w.publish)(e.cwd,e.publish),o.logger.log(`jsr publish run successfully (took ${Date.now()-n} ms)`)}catch(s){throw o.logger.log(`jsr publish failed after ${Date.now()-n} ms:`),o.logger.error(s instanceof Error?s.stack:s),s}}function d(e,o){let n=`https://jsr.io/${e.name}/versions`;return o.nextRelease&&(n=`https://jsr.io/${e.name}@${o.nextRelease.version}`),{name:"JSR.io",url:n}}async function R(e,o){let n=await l(e);await f({...n,publish:{...n.publish,publishArgs:[...n.publish.publishArgs,"--dry-run"]}},o)}async function v(e,o){let n=await l(e);for(let s of n.prepare.versionJsonPaths)await h(s,o)}async function J(e,o){let n=await l(e);return await f(n,o),d(n,o)}async function j(e,o){o.logger.log("Removing temporary folder"),await g()}async function $(e,o){o.logger.log("Removing temporary folder"),await g()}0&&(module.exports={fail,generatePublishResponse,getTemporaryBinFolder,jsrPublish,parseConfig,prepare,publish,removeTemporaryBinFolder,success,updateVersionJson,verifyConditions});
//# sourceMappingURL=index.cjs.map