{"version":3,"sources":["../src/utils.ts","../src/command.ts"],"sourcesContent":["import type {\n    NormalizedPluginConfig,\n    PluginConfig,\n    PublishResponse,\n    PublishResponseContext\n} from './types.ts';\nimport { publish as jsrPublish } from 'jsr';\nimport { tmpdir } from 'node:os';\nimport { join } from 'node:path';\nimport { existsSync, mkdtempSync } from 'node:fs';\nimport { readFile, rm, writeFile } from 'node:fs/promises';\nimport type {\n    VerifyReleaseContext,\n    VerifyConditionsContext\n} from 'semantic-release';\n\nexport async function parseConfig (config: PluginConfig): Promise<NormalizedPluginConfig> {\n    const cwd = config.cwd || process.cwd();\n\n    let pkgJsonPath: string | null = config.pkgJsonPath || join(cwd, 'package.json');\n    if (!config.pkgJsonPath && !existsSync(pkgJsonPath)) {\n        pkgJsonPath = null;\n    }\n\n    let name: string | undefined;\n    const versionJsonPaths: string[] = [];\n    const jsrJsonPath = join(cwd, 'jsr.json');\n    const denoJsonPath = join(cwd, 'deno.json');\n    if (existsSync(jsrJsonPath)) {\n        versionJsonPaths.push(jsrJsonPath);\n    }\n    if (existsSync(denoJsonPath)) {\n        versionJsonPaths.push(denoJsonPath);\n    }\n    if (pkgJsonPath) {\n        versionJsonPaths.push(pkgJsonPath);\n    }\n\n    for(const path of versionJsonPaths) {\n        const content = await readFile(path, 'utf8');\n        const json = JSON.parse(content);\n        if (!name && json.name) {\n            name = json.name;\n        }\n    }\n    if (!name) {\n        throw new Error('No name found in jsr.json or deno.json');\n    }\n\n    const publishArgs = config.publishArgs?.slice(0) || [];\n    if ((config.allowDirty === undefined || config.allowDirty) && !publishArgs.includes('--allow-dirty')) {\n        publishArgs.push('--allow-dirty');\n    }\n\n    return {\n        cwd,\n        name,\n        prepare: {\n            versionJsonPaths\n        },\n        publish: {\n            binFolder: getTemporaryBinFolder(),\n            canary: false,\n            pkgJsonPath: pkgJsonPath,\n            publishArgs\n        }\n    };\n}\n\nlet temporaryBinFolder: string | undefined;\nexport function getTemporaryBinFolder (): string {\n    if (temporaryBinFolder) {\n        return temporaryBinFolder;\n    }\n\n    const path = mkdtempSync(join(tmpdir(), 'semantic-release-jsr-'));\n    temporaryBinFolder = path;\n    return path;\n}\n\nexport async function removeTemporaryBinFolder () {\n    if (temporaryBinFolder) {\n        await rm(temporaryBinFolder, { recursive: true, force: true });\n        temporaryBinFolder = undefined;\n    }\n}\n\nexport async function updateVersionJson (file: string, context: VerifyReleaseContext) {\n    if (!context.nextRelease) {\n        return;\n    }\n\n    context.logger.log(`Updating version in ${file}`);\n    const nextVersion = context.nextRelease.version;\n    const content = await readFile(file, 'utf8');\n    const oldJson = JSON.parse(content);\n    if (oldJson.version === nextVersion) {\n        context.logger.log(`Skipped, ${file} is already up to date`);\n        return;\n    }\n\n    const versionRegex = /^([\\s\\S]*\"version\"\\s*:\\s*\")([^\"]+)(\"[\\s\\S]*$)/;\n\n    const updatedContent = content.replace(versionRegex, `$1${nextVersion}$3`);\n    const newJson = JSON.parse(updatedContent);\n    if (newJson.version !== nextVersion) {\n        throw new Error(`Failed to replace version in ${file}`);\n    }\n\n    await writeFile(file, updatedContent, 'utf8');\n    context.logger.log(`Wrote new version to ${file}`);\n}\n\nexport async function publish (config: NormalizedPluginConfig, context: VerifyConditionsContext): Promise<void> {\n    context.logger.log(`Run jsr publish in ${config.cwd} with ${JSON.stringify(config.publish)}`);\n\n    const ms = Date.now();\n    try {\n        await jsrPublish(config.cwd, config.publish);\n        context.logger.log(`jsr publish run successfully (took ${Date.now() - ms } ms)`);\n    }\n    catch (error) {\n        context.logger.log(`jsr publish failed after ${Date.now() - ms } ms:`);\n        context.logger.error(error instanceof Error ? error.stack : error);\n        throw error;\n    }\n}\n\nexport function generatePublishResponse (config: NormalizedPluginConfig, context: PublishResponseContext): PublishResponse {\n    let url = `https://jsr.io/${config.name}/versions`;\n    if (context.nextRelease) {\n        url = `https://jsr.io/${config.name}@${context.nextRelease.version}`;\n    }\n\n    return {\n        name: 'JSR.io',\n        url\n    };\n}\n","import type {\n    PluginConfig,\n    PublishResponse\n} from './types.ts';\nimport type {\n    FailContext,\n    PrepareContext,\n    PublishContext,\n    SuccessContext,\n    VerifyConditionsContext\n} from 'semantic-release';\nimport {\n    generatePublishResponse,\n    parseConfig,\n    publish as publishUtil,\n    removeTemporaryBinFolder,\n    updateVersionJson\n} from './utils.ts';\n\nexport async function verifyConditions(pluginConfig: PluginConfig, context: VerifyConditionsContext): Promise<void> {\n    const config = await parseConfig(pluginConfig);\n    await publishUtil({\n        ...config,\n        publish: {\n            ...config.publish,\n            publishArgs: [\n                ...config.publish.publishArgs,\n                '--dry-run'\n            ]\n        }\n    }, context);\n}\n\nexport async function prepare(pluginConfig: PluginConfig, context: PrepareContext): Promise<void> {\n    const config = await parseConfig(pluginConfig);\n\n    for (const file of config.prepare.versionJsonPaths) {\n        await updateVersionJson(file, context);\n    }\n}\n\nexport async function publish(pluginConfig: PluginConfig, context: PublishContext): Promise<boolean | PublishResponse> {\n    const config = await parseConfig(pluginConfig);\n    await publishUtil(config, context);\n    return generatePublishResponse(config, context);\n}\n\nexport async function success (pluginConfig: PluginConfig, context: SuccessContext) {\n    context.logger.log('Removing temporary folder');\n    await removeTemporaryBinFolder();\n}\n\nexport async function fail (pluginConfig: PluginConfig, context: FailContext) {\n    context.logger.log('Removing temporary folder');\n    await removeTemporaryBinFolder();\n}\n"],"mappings":"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","names":["jsrPublish","tmpdir","join","existsSync","mkdtempSync","readFile","rm","writeFile","parseConfig","config","cwd","pkgJsonPath","name","versionJsonPaths","jsrJsonPath","denoJsonPath","path","content","json","publishArgs","getTemporaryBinFolder","temporaryBinFolder","removeTemporaryBinFolder","updateVersionJson","file","context","nextVersion","versionRegex","updatedContent","publish","ms","error","generatePublishResponse","url","verifyConditions","pluginConfig","context","config","parseConfig","publish","prepare","file","updateVersionJson","generatePublishResponse","success","removeTemporaryBinFolder","fail"]}