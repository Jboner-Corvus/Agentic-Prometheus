{"version":3,"sources":["/home/allah/Desktop/github/fastmcp/dist/FastMCP.cjs","../src/FastMCP.ts"],"names":[],"mappings":"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","file":"/home/allah/Desktop/github/fastmcp/dist/FastMCP.cjs","sourcesContent":[null,"import { Server } from \"@modelcontextprotocol/sdk/server/index.js\";\nimport { StdioServerTransport } from \"@modelcontextprotocol/sdk/server/stdio.js\";\nimport { Transport } from \"@modelcontextprotocol/sdk/shared/transport.js\";\nimport {\n  CallToolRequestSchema,\n  ClientCapabilities,\n  CompleteRequestSchema,\n  CreateMessageRequestSchema,\n  ErrorCode,\n  GetPromptRequestSchema,\n  ListPromptsRequestSchema,\n  ListResourcesRequestSchema,\n  ListResourceTemplatesRequestSchema,\n  ListToolsRequestSchema,\n  McpError,\n  ReadResourceRequestSchema,\n  Root,\n  RootsListChangedNotificationSchema,\n  ServerCapabilities,\n  SetLevelRequestSchema,\n} from \"@modelcontextprotocol/sdk/types.js\";\nimport { StandardSchemaV1 } from \"@standard-schema/spec\";\nimport { randomUUID } from \"crypto\"; // Import pour générer des UUID\nimport { EventEmitter } from \"events\";\nimport { fileTypeFromBuffer } from \"file-type\";\nimport { readFile } from \"fs/promises\";\nimport Fuse from \"fuse.js\";\nimport http from \"http\";\nimport { startHTTPServer } from \"mcp-proxy\";\nimport { StrictEventEmitter } from \"strict-event-emitter-types\";\nimport { setTimeout as delay } from \"timers/promises\";\nimport { fetch } from \"undici\";\nimport parseURITemplate from \"uri-templates\";\nimport { toJsonSchema } from \"xsschema\";\nimport { z } from \"zod\";\n\nexport type SSEServer = {\n  close: () => Promise<void>;\n};\n\ntype FastMCPEvents<T extends FastMCPSessionAuth> = {\n  connect: (event: { session: FastMCPSession<T> }) => void;\n  disconnect: (event: { session: FastMCPSession<T> }) => void;\n};\n\ntype FastMCPSessionEvents = {\n  error: (event: { error: Error }) => void;\n  rootsChanged: (event: { roots: Root[] }) => void;\n};\n\nexport const imageContent = async (\n  input: { buffer: Buffer } | { path: string } | { url: string },\n): Promise<ImageContent> => {\n  let rawData: Buffer;\n\n  try {\n    if (\"url\" in input) {\n      try {\n        const response = await fetch(input.url);\n\n        if (!response.ok) {\n          throw new Error(\n            `Server responded with status: ${response.status} - ${response.statusText}`,\n          );\n        }\n\n        rawData = Buffer.from(await response.arrayBuffer());\n      } catch (error) {\n        throw new Error(\n          `Failed to fetch image from URL (${input.url}): ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    } else if (\"path\" in input) {\n      try {\n        rawData = await readFile(input.path);\n      } catch (error) {\n        throw new Error(\n          `Failed to read image from path (${input.path}): ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    } else if (\"buffer\" in input) {\n      rawData = input.buffer;\n    } else {\n      throw new Error(\n        \"Invalid input: Provide a valid 'url', 'path', or 'buffer'\",\n      );\n    }\n\n    const mimeType = await fileTypeFromBuffer(rawData);\n\n    if (!mimeType || !mimeType.mime.startsWith(\"image/\")) {\n      console.warn(\n        `Warning: Content may not be a valid image. Detected MIME: ${mimeType?.mime || \"unknown\"}`,\n      );\n    }\n\n    const base64Data = rawData.toString(\"base64\");\n\n    return {\n      data: base64Data,\n      mimeType: mimeType?.mime ?? \"image/png\",\n      type: \"image\",\n    } as const;\n  } catch (error) {\n    if (error instanceof Error) {\n      throw error;\n    } else {\n      throw new Error(`Unexpected error processing image: ${String(error)}`);\n    }\n  }\n};\n\nexport const audioContent = async (\n  input: { buffer: Buffer } | { path: string } | { url: string },\n): Promise<AudioContent> => {\n  let rawData: Buffer;\n\n  try {\n    if (\"url\" in input) {\n      try {\n        const response = await fetch(input.url);\n\n        if (!response.ok) {\n          throw new Error(\n            `Server responded with status: ${response.status} - ${response.statusText}`,\n          );\n        }\n\n        rawData = Buffer.from(await response.arrayBuffer());\n      } catch (error) {\n        throw new Error(\n          `Failed to fetch audio from URL (${input.url}): ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    } else if (\"path\" in input) {\n      try {\n        rawData = await readFile(input.path);\n      } catch (error) {\n        throw new Error(\n          `Failed to read audio from path (${input.path}): ${error instanceof Error ? error.message : String(error)}`,\n        );\n      }\n    } else if (\"buffer\" in input) {\n      rawData = input.buffer;\n    } else {\n      throw new Error(\n        \"Invalid input: Provide a valid 'url', 'path', or 'buffer'\",\n      );\n    }\n\n    const mimeType = await fileTypeFromBuffer(rawData);\n\n    if (!mimeType || !mimeType.mime.startsWith(\"audio/\")) {\n      console.warn(\n        `Warning: Content may not be a valid audio file. Detected MIME: ${mimeType?.mime || \"unknown\"}`,\n      );\n    }\n\n    const base64Data = rawData.toString(\"base64\");\n\n    return {\n      data: base64Data,\n      mimeType: mimeType?.mime ?? \"audio/mpeg\",\n      type: \"audio\",\n    } as const;\n  } catch (error) {\n    if (error instanceof Error) {\n      throw error;\n    } else {\n      throw new Error(`Unexpected error processing audio: ${String(error)}`);\n    }\n  }\n};\n\ntype Context<T extends FastMCPSessionAuth> = {\n  /**\n   * The authentication data returned by the server's `authenticate` function.\n   * This is specific to your application's authentication logic.\n   */\n  authData: T | undefined;\n  /**\n   * The unique identifier for the current FastMCP session, generated by the framework.\n   */\n  frameworkSessionId: string;\n  log: {\n    debug: (message: string, data?: SerializableValue) => void;\n    error: (message: string, data?: SerializableValue) => void;\n    info: (message: string, data?: SerializableValue) => void;\n    warn: (message: string, data?: SerializableValue) => void;\n  };\n  reportProgress: (progress: Progress) => Promise<void>;\n  streamContent: (content: Content | Content[]) => Promise<void>;\n};\n\ntype Extra = unknown;\n\ntype Extras = Record<string, Extra>;\n\ntype Literal = boolean | null | number | string | undefined;\n\ntype Progress = {\n  /**\n   * The progress thus far. This should increase every time progress is made, even if the total is unknown.\n   */\n  progress: number;\n  /**\n   * Total number of items to process (or total progress required), if known.\n   */\n  total?: number;\n};\n\ntype SerializableValue =\n  | { [key: string]: SerializableValue }\n  | Literal\n  | SerializableValue[];\n\ntype TextContent = {\n  text: string;\n  type: \"text\";\n};\n\ntype ToolParameters = StandardSchemaV1;\n\nabstract class FastMCPError extends Error {\n  public constructor(message?: string) {\n    super(message);\n    this.name = new.target.name;\n  }\n}\n\nexport class UnexpectedStateError extends FastMCPError {\n  public extras?: Extras;\n\n  public constructor(message: string, extras?: Extras) {\n    super(message);\n    this.name = new.target.name;\n    this.extras = extras;\n  }\n}\n\n/**\n * An error that is meant to be surfaced to the user.\n */\nexport class UserError extends UnexpectedStateError {}\n\nconst TextContentZodSchema = z\n  .object({\n    /**\n     * The text content of the message.\n     */\n    text: z.string(),\n    type: z.literal(\"text\"),\n  })\n  .strict() satisfies z.ZodType<TextContent>;\n\ntype ImageContent = {\n  data: string;\n  mimeType: string;\n  type: \"image\";\n};\n\nconst ImageContentZodSchema = z\n  .object({\n    /**\n     * The base64-encoded image data.\n     */\n    data: z.string().base64(),\n    /**\n     * The MIME type of the image. Different providers may support different image types.\n     */\n    mimeType: z.string(),\n    type: z.literal(\"image\"),\n  })\n  .strict() satisfies z.ZodType<ImageContent>;\n\ntype AudioContent = {\n  data: string;\n  mimeType: string;\n  type: \"audio\";\n};\n\nconst AudioContentZodSchema = z\n  .object({\n    /**\n     * The base64-encoded audio data.\n     */\n    data: z.string().base64(),\n    mimeType: z.string(),\n    type: z.literal(\"audio\"),\n  })\n  .strict() satisfies z.ZodType<AudioContent>;\n\ntype Content = AudioContent | ImageContent | TextContent;\n\nconst ContentZodSchema = z.discriminatedUnion(\"type\", [\n  TextContentZodSchema,\n  ImageContentZodSchema,\n  AudioContentZodSchema,\n]) satisfies z.ZodType<Content>;\n\ntype ContentResult = {\n  content: Content[];\n  isError?: boolean;\n};\n\nconst ContentResultZodSchema = z\n  .object({\n    content: ContentZodSchema.array(),\n    isError: z.boolean().optional(),\n  })\n  .strict() satisfies z.ZodType<ContentResult>;\n\ntype Completion = {\n  hasMore?: boolean;\n  total?: number;\n  values: string[];\n};\n\n/**\n * https://github.com/modelcontextprotocol/typescript-sdk/blob/3164da64d085ec4e022ae881329eee7b72f208d4/src/types.ts#L983-L1003\n */\nconst CompletionZodSchema = z.object({\n  /**\n   * Indicates whether there are additional completion options beyond those provided in the current response, even if the exact total is unknown.\n   */\n  hasMore: z.optional(z.boolean()),\n  /**\n   * The total number of completion options available. This can exceed the number of values actually sent in the response.\n   */\n  total: z.optional(z.number().int()),\n  /**\n   * An array of completion values. Must not exceed 100 items.\n   */\n  values: z.array(z.string()).max(100),\n}) satisfies z.ZodType<Completion>;\n\ntype ArgumentValueCompleter = (value: string) => Promise<Completion>;\n\ntype InputPrompt<\n  Arguments extends InputPromptArgument[] = InputPromptArgument[],\n  Args = PromptArgumentsToObject<Arguments>,\n> = {\n  arguments?: InputPromptArgument[];\n  description?: string;\n  load: (args: Args) => Promise<string>;\n  name: string;\n};\n\ntype InputPromptArgument = Readonly<{\n  complete?: ArgumentValueCompleter;\n  description?: string;\n  enum?: string[];\n  name: string;\n  required?: boolean;\n}>;\n\ntype InputResourceTemplate<\n  Arguments extends ResourceTemplateArgument[] = ResourceTemplateArgument[],\n> = {\n  arguments: Arguments;\n  description?: string;\n  load: (\n    args: ResourceTemplateArgumentsToObject<Arguments>,\n  ) => Promise<ResourceResult>;\n  mimeType?: string;\n  name: string;\n  uriTemplate: string;\n};\n\ntype InputResourceTemplateArgument = Readonly<{\n  complete?: ArgumentValueCompleter;\n  description?: string;\n  name: string;\n  required?: boolean;\n}>;\n\ntype LoggingLevel =\n  | \"alert\"\n  | \"critical\"\n  | \"debug\"\n  | \"emergency\"\n  | \"error\"\n  | \"info\"\n  | \"notice\"\n  | \"warning\";\n\ntype Prompt<\n  Arguments extends PromptArgument[] = PromptArgument[],\n  Args = PromptArgumentsToObject<Arguments>,\n> = {\n  arguments?: PromptArgument[];\n  complete?: (name: string, value: string) => Promise<Completion>;\n  description?: string;\n  load: (args: Args) => Promise<string>;\n  name: string;\n};\n\ntype PromptArgument = Readonly<{\n  complete?: ArgumentValueCompleter;\n  description?: string;\n  enum?: string[];\n  name: string;\n  required?: boolean;\n}>;\n\ntype PromptArgumentsToObject<T extends { name: string; required?: boolean }[]> =\n  {\n    [K in T[number][\"name\"]]: Extract<\n      T[number],\n      { name: K }\n    >[\"required\"] extends true\n      ? string\n      : string | undefined;\n  };\n\ntype Resource = {\n  complete?: (name: string, value: string) => Promise<Completion>;\n  description?: string;\n  load: () => Promise<ResourceResult | ResourceResult[]>;\n  mimeType?: string;\n  name: string;\n  uri: string;\n};\n\ntype ResourceResult =\n  | {\n      blob: string;\n    }\n  | {\n      text: string;\n    };\n\ntype ResourceTemplate<\n  Arguments extends ResourceTemplateArgument[] = ResourceTemplateArgument[],\n> = {\n  arguments: Arguments;\n  complete?: (name: string, value: string) => Promise<Completion>;\n  description?: string;\n  load: (\n    args: ResourceTemplateArgumentsToObject<Arguments>,\n  ) => Promise<ResourceResult>;\n  mimeType?: string;\n  name: string;\n  uriTemplate: string;\n};\n\ntype ResourceTemplateArgument = Readonly<{\n  complete?: ArgumentValueCompleter;\n  description?: string;\n  name: string;\n  required?: boolean;\n}>;\n\ntype ResourceTemplateArgumentsToObject<T extends { name: string }[]> = {\n  [K in T[number][\"name\"]]: string;\n};\n\ntype ServerOptions<T extends FastMCPSessionAuth> = {\n  authenticate?: Authenticate<T>;\n  /**\n   * Configuration for the health-check endpoint that can be exposed when the\n   * server is running using the HTTP Stream transport. When enabled, the\n   * server will respond to an HTTP GET request with the configured path (by\n   * default \"/health\") rendering a plain-text response (by default \"ok\") and\n   * the configured status code (by default 200).\n   *\n   * The endpoint is only added when the server is started with\n   * `transportType: \"httpStream\"` – it is ignored for the stdio transport.\n   */\n  health?: {\n    /**\n     * When set to `false` the health-check endpoint is disabled.\n     * @default true\n     */\n    enabled?: boolean;\n\n    /**\n     * Plain-text body returned by the endpoint.\n     * @default \"ok\"\n     */\n    message?: string;\n\n    /**\n     * HTTP path that should be handled.\n     * @default \"/health\"\n     */\n    path?: string;\n\n    /**\n     * HTTP response status that will be returned.\n     * @default 200\n     */\n    status?: number;\n  };\n  instructions?: string;\n  name: string;\n\n  ping?: {\n    /**\n     * Whether ping should be enabled by default.\n     * - true for SSE or HTTP Stream\n     * - false for stdio\n     */\n    enabled?: boolean;\n    /**\n     * Interval\n     * @default 5000 (5s)\n     */\n    intervalMs?: number;\n    /**\n     * Logging level for ping-related messages.\n     * @default 'debug'\n     */\n    logLevel?: LoggingLevel;\n  };\n  /**\n   * Configuration for roots capability\n   */\n  roots?: {\n    /**\n     * Whether roots capability should be enabled\n     * Set to false to completely disable roots support\n     * @default true\n     */\n    enabled?: boolean;\n  };\n  version: `${number}.${number}.${number}`;\n};\n\ntype Tool<\n  T extends FastMCPSessionAuth,\n  Params extends ToolParameters = ToolParameters,\n> = {\n  annotations?: {\n    /**\n     * When true, the tool leverages incremental content streaming\n     * Return void for tools that handle all their output via streaming\n     */\n    streamingHint?: boolean;\n  } & ToolAnnotations;\n  description?: string;\n  execute: (\n    args: StandardSchemaV1.InferOutput<Params>,\n    context: Context<T>,\n  ) => Promise<\n    AudioContent | ContentResult | ImageContent | string | TextContent | void\n  >;\n  name: string;\n  parameters?: Params;\n  timeoutMs?: number;\n};\n\n/**\n * Tool annotations as defined in MCP Specification (2025-03-26)\n * These provide hints about a tool's behavior.\n */\ntype ToolAnnotations = {\n  /**\n   * If true, the tool may perform destructive updates\n   * Only meaningful when readOnlyHint is false\n   * @default true\n   */\n  destructiveHint?: boolean;\n\n  /**\n   * If true, calling the tool repeatedly with the same arguments has no additional effect\n   * Only meaningful when readOnlyHint is false\n   * @default false\n   */\n  idempotentHint?: boolean;\n\n  /**\n   * If true, the tool may interact with an \"open world\" of external entities\n   * @default true\n   */\n  openWorldHint?: boolean;\n\n  /**\n   * If true, indicates the tool does not modify its environment\n   * @default false\n   */\n  readOnlyHint?: boolean;\n\n  /**\n   * A human-readable title for the tool, useful for UI display\n   */\n  title?: string;\n};\n\nconst FastMCPSessionEventEmitterBase: {\n  new (): StrictEventEmitter<EventEmitter, FastMCPSessionEvents>;\n} = EventEmitter;\n\ntype FastMCPSessionAuth = Record<string, unknown> | undefined;\n\ntype SamplingResponse = {\n  content: AudioContent | ImageContent | TextContent;\n  model: string;\n  role: \"assistant\" | \"user\";\n  stopReason?: \"endTurn\" | \"maxTokens\" | \"stopSequence\" | string;\n};\n\nclass FastMCPSessionEventEmitter extends FastMCPSessionEventEmitterBase {}\n\nexport class FastMCPSession<\n  T extends FastMCPSessionAuth = FastMCPSessionAuth,\n> extends FastMCPSessionEventEmitter {\n  public readonly frameworkSessionId: string; // Unique ID for this FastMCP session instance\n\n  public get clientCapabilities(): ClientCapabilities | null {\n    return this.#clientCapabilities ?? null;\n  }\n  public get loggingLevel(): LoggingLevel {\n    return this.#loggingLevel;\n  }\n  public get roots(): Root[] {\n    return this.#roots;\n  }\n  public get server(): Server {\n    return this.#server;\n  }\n  #auth: T | undefined;\n  #capabilities: ServerCapabilities = {};\n  #clientCapabilities?: ClientCapabilities;\n  #loggingLevel: LoggingLevel = \"info\";\n  #pingConfig?: ServerOptions<T>[\"ping\"];\n  #pingInterval: null | ReturnType<typeof setInterval> = null;\n\n  #prompts: Prompt[] = [];\n\n  #resources: Resource[] = [];\n\n  #resourceTemplates: ResourceTemplate[] = [];\n\n  #roots: Root[] = [];\n\n  #rootsConfig?: ServerOptions<T>[\"roots\"];\n\n  #server: Server;\n\n  constructor({\n    auth,\n    instructions,\n    name,\n    ping,\n    prompts,\n    resources,\n    resourcesTemplates,\n    roots,\n    tools,\n    version,\n  }: {\n    auth?: T;\n    instructions?: string;\n    name: string;\n    ping?: ServerOptions<T>[\"ping\"];\n    prompts: Prompt[];\n    resources: Resource[];\n    resourcesTemplates: InputResourceTemplate[];\n    roots?: ServerOptions<T>[\"roots\"];\n    tools: Tool<T>[];\n    version: string;\n  }) {\n    super();\n    this.frameworkSessionId = randomUUID(); // Generate a unique ID for this session\n    this.#auth = auth;\n    this.#pingConfig = ping;\n    this.#rootsConfig = roots;\n\n    if (tools.length) {\n      this.#capabilities.tools = {};\n    }\n\n    if (resources.length || resourcesTemplates.length) {\n      this.#capabilities.resources = {};\n    }\n\n    if (prompts.length) {\n      for (const prompt of prompts) {\n        this.addPrompt(prompt);\n      }\n\n      this.#capabilities.prompts = {};\n    }\n\n    this.#capabilities.logging = {};\n\n    this.#server = new Server(\n      { name: name, version: version },\n      { capabilities: this.#capabilities, instructions: instructions },\n    );\n\n    this.setupErrorHandling();\n    this.setupLoggingHandlers();\n    this.setupRootsHandlers();\n    this.setupCompleteHandlers();\n\n    if (tools.length) {\n      this.setupToolHandlers(tools);\n    }\n\n    if (resources.length || resourcesTemplates.length) {\n      for (const resource of resources) {\n        this.addResource(resource);\n      }\n\n      this.setupResourceHandlers(resources);\n\n      if (resourcesTemplates.length) {\n        for (const resourceTemplate of resourcesTemplates) {\n          this.addResourceTemplate(resourceTemplate);\n        }\n\n        this.setupResourceTemplateHandlers(resourcesTemplates);\n      }\n    }\n\n    if (prompts.length) {\n      this.setupPromptHandlers(prompts);\n    }\n  }\n\n  public async close() {\n    if (this.#pingInterval) {\n      clearInterval(this.#pingInterval);\n    }\n\n    try {\n      await this.#server.close();\n    } catch (error) {\n      console.error(\"[FastMCP error]\", \"could not close server\", error);\n    }\n  }\n\n  public async connect(transport: Transport) {\n    if (this.#server.transport) {\n      throw new UnexpectedStateError(\"Server is already connected\");\n    }\n\n    await this.#server.connect(transport);\n\n    let attempt = 0;\n\n    while (attempt++ < 10) {\n      const capabilities = await this.#server.getClientCapabilities();\n\n      if (capabilities) {\n        this.#clientCapabilities = capabilities;\n\n        break;\n      }\n\n      await delay(100);\n    }\n\n    if (!this.#clientCapabilities) {\n      console.warn(\"[FastMCP warning] could not infer client capabilities\");\n    }\n\n    if (\n      this.#clientCapabilities?.roots?.listChanged &&\n      typeof this.#server.listRoots === \"function\"\n    ) {\n      try {\n        const roots = await this.#server.listRoots();\n        this.#roots = roots.roots;\n      } catch (e) {\n        if (e instanceof McpError && e.code === ErrorCode.MethodNotFound) {\n          console.debug(\n            \"[FastMCP debug] listRoots method not supported by client\",\n          );\n        } else {\n          console.error(\n            `[FastMCP error] received error listing roots.\\n\\n${e instanceof Error ? e.stack : JSON.stringify(e)}`,\n          );\n        }\n      }\n    }\n\n    if (this.#clientCapabilities) {\n      const pingConfig = this.#getPingConfig(transport);\n\n      if (pingConfig.enabled) {\n        this.#pingInterval = setInterval(async () => {\n          try {\n            await this.#server.ping();\n          } catch {\n            // The reason we are not emitting an error here is because some clients\n            // seem to not respond to the ping request, and we don't want to crash the server,\n            // e.g., https://github.com/punkpeye/fastmcp/issues/38.\n            const logLevel = pingConfig.logLevel;\n            if (logLevel === \"debug\") {\n              console.debug(\"[FastMCP debug] server ping failed\");\n            } else if (logLevel === \"warning\") {\n              console.warn(\n                \"[FastMCP warning] server is not responding to ping\",\n              );\n            } else if (logLevel === \"error\") {\n              console.error(\"[FastMCP error] server is not responding to ping\");\n            } else {\n              console.info(\"[FastMCP info] server ping failed\");\n            }\n          }\n        }, pingConfig.intervalMs);\n      }\n    }\n  }\n\n  public async requestSampling(\n    message: z.infer<typeof CreateMessageRequestSchema>[\"params\"],\n  ): Promise<SamplingResponse> {\n    return this.#server.createMessage(message);\n  }\n\n  #getPingConfig(transport: Transport): {\n    enabled: boolean;\n    intervalMs: number;\n    logLevel: LoggingLevel;\n  } {\n    const pingConfig = this.#pingConfig || {};\n\n    let defaultEnabled = false;\n\n    if (\"type\" in transport) {\n      // Enable by default for SSE and HTTP streaming\n      if (transport.type === \"httpStream\") {\n        defaultEnabled = true;\n      }\n    }\n\n    return {\n      enabled:\n        pingConfig.enabled !== undefined ? pingConfig.enabled : defaultEnabled,\n      intervalMs: pingConfig.intervalMs || 5000,\n      logLevel: pingConfig.logLevel || \"debug\",\n    };\n  }\n\n  private addPrompt(inputPrompt: InputPrompt) {\n    const completers: Record<string, ArgumentValueCompleter> = {};\n    const enums: Record<string, string[]> = {};\n\n    for (const argument of inputPrompt.arguments ?? []) {\n      if (argument.complete) {\n        completers[argument.name] = argument.complete;\n      }\n\n      if (argument.enum) {\n        enums[argument.name] = argument.enum;\n      }\n    }\n\n    const prompt = {\n      ...inputPrompt,\n      complete: async (name: string, value: string) => {\n        if (completers[name]) {\n          return await completers[name](value);\n        }\n\n        if (enums[name]) {\n          const fuse = new Fuse(enums[name], {\n            keys: [\"value\"],\n          });\n\n          const result = fuse.search(value);\n\n          return {\n            total: result.length,\n            values: result.map((item) => item.item),\n          };\n        }\n\n        return {\n          values: [],\n        };\n      },\n    };\n\n    this.#prompts.push(prompt);\n  }\n\n  private addResource(inputResource: Resource) {\n    this.#resources.push(inputResource);\n  }\n\n  private addResourceTemplate(inputResourceTemplate: InputResourceTemplate) {\n    const completers: Record<string, ArgumentValueCompleter> = {};\n\n    for (const argument of inputResourceTemplate.arguments ?? []) {\n      if (argument.complete) {\n        completers[argument.name] = argument.complete;\n      }\n    }\n\n    const resourceTemplate = {\n      ...inputResourceTemplate,\n      complete: async (name: string, value: string) => {\n        if (completers[name]) {\n          return await completers[name](value);\n        }\n\n        return {\n          values: [],\n        };\n      },\n    };\n\n    this.#resourceTemplates.push(resourceTemplate);\n  }\n\n  private setupCompleteHandlers() {\n    this.#server.setRequestHandler(CompleteRequestSchema, async (request) => {\n      if (request.params.ref.type === \"ref/prompt\") {\n        const prompt = this.#prompts.find(\n          (prompt) => prompt.name === request.params.ref.name,\n        );\n\n        if (!prompt) {\n          throw new UnexpectedStateError(\"Unknown prompt\", {\n            request,\n          });\n        }\n\n        if (!prompt.complete) {\n          throw new UnexpectedStateError(\"Prompt does not support completion\", {\n            request,\n          });\n        }\n\n        const completion = CompletionZodSchema.parse(\n          await prompt.complete(\n            request.params.argument.name,\n            request.params.argument.value,\n          ),\n        );\n\n        return {\n          completion,\n        };\n      }\n\n      if (request.params.ref.type === \"ref/resource\") {\n        const resource = this.#resourceTemplates.find(\n          (resource) => resource.uriTemplate === request.params.ref.uri,\n        );\n\n        if (!resource) {\n          throw new UnexpectedStateError(\"Unknown resource\", {\n            request,\n          });\n        }\n\n        if (!(\"uriTemplate\" in resource)) {\n          throw new UnexpectedStateError(\"Unexpected resource\");\n        }\n\n        if (!resource.complete) {\n          throw new UnexpectedStateError(\n            \"Resource does not support completion\",\n            {\n              request,\n            },\n          );\n        }\n\n        const completion = CompletionZodSchema.parse(\n          await resource.complete(\n            request.params.argument.name,\n            request.params.argument.value,\n          ),\n        );\n\n        return {\n          completion,\n        };\n      }\n\n      throw new UnexpectedStateError(\"Unexpected completion request\", {\n        request,\n      });\n    });\n  }\n\n  private setupErrorHandling() {\n    this.#server.onerror = (error) => {\n      console.error(\"[FastMCP error]\", error);\n    };\n  }\n\n  private setupLoggingHandlers() {\n    this.#server.setRequestHandler(SetLevelRequestSchema, (request) => {\n      this.#loggingLevel = request.params.level;\n\n      return {};\n    });\n  }\n\n  private setupPromptHandlers(prompts: Prompt[]) {\n    this.#server.setRequestHandler(ListPromptsRequestSchema, async () => {\n      return {\n        prompts: prompts.map((prompt) => {\n          return {\n            arguments: prompt.arguments,\n            complete: prompt.complete,\n            description: prompt.description,\n            name: prompt.name,\n          };\n        }),\n      };\n    });\n\n    this.#server.setRequestHandler(GetPromptRequestSchema, async (request) => {\n      const prompt = prompts.find(\n        (prompt) => prompt.name === request.params.name,\n      );\n\n      if (!prompt) {\n        throw new McpError(\n          ErrorCode.MethodNotFound,\n          `Unknown prompt: ${request.params.name}`,\n        );\n      }\n\n      const args = request.params.arguments;\n\n      for (const arg of prompt.arguments ?? []) {\n        if (arg.required && !(args && arg.name in args)) {\n          throw new McpError(\n            ErrorCode.InvalidRequest,\n            `Missing required argument: ${arg.name}`,\n          );\n        }\n      }\n\n      let result: Awaited<ReturnType<Prompt[\"load\"]>>;\n\n      try {\n        result = await prompt.load(args as Record<string, string | undefined>);\n      } catch (error) {\n        throw new McpError(\n          ErrorCode.InternalError,\n          `Error loading prompt: ${error}`,\n        );\n      }\n\n      return {\n        description: prompt.description,\n        messages: [\n          {\n            content: { text: result, type: \"text\" },\n            role: \"user\",\n          },\n        ],\n      };\n    });\n  }\n\n  private setupResourceHandlers(resources: Resource[]) {\n    this.#server.setRequestHandler(ListResourcesRequestSchema, async () => {\n      return {\n        resources: resources.map((resource) => {\n          return {\n            mimeType: resource.mimeType,\n            name: resource.name,\n            uri: resource.uri,\n          };\n        }),\n      };\n    });\n\n    this.#server.setRequestHandler(\n      ReadResourceRequestSchema,\n      async (request) => {\n        if (\"uri\" in request.params) {\n          const resource = resources.find(\n            (resource) =>\n              \"uri\" in resource && resource.uri === request.params.uri,\n          );\n\n          if (!resource) {\n            for (const resourceTemplate of this.#resourceTemplates) {\n              const uriTemplate = parseURITemplate(\n                resourceTemplate.uriTemplate,\n              );\n\n              const match = uriTemplate.fromUri(request.params.uri);\n\n              if (!match) {\n                continue;\n              }\n\n              const uri = uriTemplate.fill(match);\n\n              const result = await resourceTemplate.load(match);\n\n              return {\n                contents: [\n                  {\n                    mimeType: resourceTemplate.mimeType,\n                    name: resourceTemplate.name,\n                    uri: uri,\n                    ...result,\n                  },\n                ],\n              };\n            }\n\n            throw new McpError(\n              ErrorCode.MethodNotFound,\n              `Unknown resource: ${request.params.uri}`,\n            );\n          }\n\n          if (!(\"uri\" in resource)) {\n            throw new UnexpectedStateError(\"Resource does not support reading\");\n          }\n\n          let maybeArrayResult: Awaited<ReturnType<Resource[\"load\"]>>;\n\n          try {\n            maybeArrayResult = await resource.load();\n          } catch (error) {\n            throw new McpError(\n              ErrorCode.InternalError,\n              `Error reading resource: ${error}`,\n              {\n                uri: resource.uri,\n              },\n            );\n          }\n\n          if (Array.isArray(maybeArrayResult)) {\n            return {\n              contents: maybeArrayResult.map((result) => ({\n                mimeType: resource.mimeType,\n                name: resource.name,\n                uri: resource.uri,\n                ...result,\n              })),\n            };\n          } else {\n            return {\n              contents: [\n                {\n                  mimeType: resource.mimeType,\n                  name: resource.name,\n                  uri: resource.uri,\n                  ...maybeArrayResult,\n                },\n              ],\n            };\n          }\n        }\n\n        throw new UnexpectedStateError(\"Unknown resource request\", {\n          request,\n        });\n      },\n    );\n  }\n\n  private setupResourceTemplateHandlers(resourceTemplates: ResourceTemplate[]) {\n    this.#server.setRequestHandler(\n      ListResourceTemplatesRequestSchema,\n      async () => {\n        return {\n          resourceTemplates: resourceTemplates.map((resourceTemplate) => {\n            return {\n              name: resourceTemplate.name,\n              uriTemplate: resourceTemplate.uriTemplate,\n            };\n          }),\n        };\n      },\n    );\n  }\n\n  private setupRootsHandlers() {\n    if (this.#rootsConfig?.enabled === false) {\n      console.debug(\n        \"[FastMCP debug] roots capability explicitly disabled via config\",\n      );\n      return;\n    }\n\n    // Only set up roots notification handling if the server supports it\n    if (typeof this.#server.listRoots === \"function\") {\n      this.#server.setNotificationHandler(\n        RootsListChangedNotificationSchema,\n        () => {\n          this.#server\n            .listRoots()\n            .then((roots) => {\n              this.#roots = roots.roots;\n\n              this.emit(\"rootsChanged\", {\n                roots: roots.roots,\n              });\n            })\n            .catch((error) => {\n              if (\n                error instanceof McpError &&\n                error.code === ErrorCode.MethodNotFound\n              ) {\n                console.debug(\n                  \"[FastMCP debug] listRoots method not supported by client\",\n                );\n              } else {\n                console.error(\"[FastMCP error] Error listing roots\", error);\n              }\n            });\n        },\n      );\n    } else {\n      console.debug(\n        \"[FastMCP debug] roots capability not available, not setting up notification handler\",\n      );\n    }\n  }\n\n  private setupToolHandlers(tools: Tool<T>[]) {\n    this.#server.setRequestHandler(ListToolsRequestSchema, async () => {\n      return {\n        tools: await Promise.all(\n          tools.map(async (tool) => {\n            return {\n              annotations: tool.annotations,\n              description: tool.description,\n              inputSchema: tool.parameters\n                ? await toJsonSchema(tool.parameters)\n                : {\n                    additionalProperties: false,\n                    properties: {},\n                    type: \"object\",\n                  }, // More complete schema for Cursor compatibility\n              name: tool.name,\n            };\n          }),\n        ),\n      };\n    });\n\n    this.#server.setRequestHandler(CallToolRequestSchema, async (request) => {\n      const tool = tools.find((tool) => tool.name === request.params.name);\n\n      if (!tool) {\n        throw new McpError(\n          ErrorCode.MethodNotFound,\n          `Unknown tool: ${request.params.name}`,\n        );\n      }\n\n      let args: unknown = undefined;\n\n      if (tool.parameters) {\n        const parsed = await tool.parameters[\"~standard\"].validate(\n          request.params.arguments,\n        );\n\n        if (parsed.issues) {\n          throw new McpError(\n            ErrorCode.InvalidParams,\n            `Invalid ${request.params.name} parameters: ${JSON.stringify(parsed.issues)}`,\n          );\n        }\n\n        args = parsed.value;\n      }\n\n      const progressToken = request.params?._meta?.progressToken;\n\n      let result: ContentResult;\n\n      try {\n        const reportProgress = async (progress: Progress) => {\n          await this.#server.notification({\n            method: \"notifications/progress\",\n            params: {\n              ...progress,\n              progressToken,\n            },\n          });\n        };\n\n        const log = {\n          debug: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              data: {\n                context,\n                message,\n              },\n              level: \"debug\",\n            });\n          },\n          error: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              data: {\n                context,\n                message,\n              },\n              level: \"error\",\n            });\n          },\n          info: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              data: {\n                context,\n                message,\n              },\n              level: \"info\",\n            });\n          },\n          warn: (message: string, context?: SerializableValue) => {\n            this.#server.sendLoggingMessage({\n              data: {\n                context,\n                message,\n              },\n              level: \"warning\",\n            });\n          },\n        };\n\n        // Create a promise for tool execution\n        // Streams partial results while a tool is still executing\n        // Enables progressive rendering and real-time feedback\n        const streamContent = async (content: Content | Content[]) => {\n          const contentArray = Array.isArray(content) ? content : [content];\n\n          await this.#server.notification({\n            method: \"notifications/tool/streamContent\",\n            params: {\n              content: contentArray,\n              toolName: request.params.name,\n            },\n          });\n        };\n\n        const toolContext: Context<T> = {\n          authData: this.#auth,\n          frameworkSessionId: this.frameworkSessionId,\n          log,\n          reportProgress,\n          streamContent,\n        };\n\n        const executeToolPromise = tool.execute(args, toolContext);\n\n        // Handle timeout if specified\n        const maybeStringResult = (await (tool.timeoutMs\n          ? Promise.race([\n              executeToolPromise,\n              new Promise<never>((_, reject) => {\n                setTimeout(() => {\n                  reject(\n                    new UserError(\n                      `Tool execution timed out after ${tool.timeoutMs}ms`,\n                    ),\n                  );\n                }, tool.timeoutMs);\n              }),\n            ])\n          : executeToolPromise)) as\n          | AudioContent\n          | ContentResult\n          | ImageContent\n          | null\n          | string\n          | TextContent\n          | undefined;\n\n        if (maybeStringResult === undefined || maybeStringResult === null) {\n          result = ContentResultZodSchema.parse({\n            content: [],\n          });\n        } else if (typeof maybeStringResult === \"string\") {\n          result = ContentResultZodSchema.parse({\n            content: [{ text: maybeStringResult, type: \"text\" }],\n          });\n        } else if (\"type\" in maybeStringResult) {\n          result = ContentResultZodSchema.parse({\n            content: [maybeStringResult],\n          });\n        } else {\n          result = ContentResultZodSchema.parse(maybeStringResult);\n        }\n      } catch (error) {\n        if (error instanceof UserError) {\n          return {\n            content: [{ text: error.message, type: \"text\" }],\n            isError: true,\n          };\n        }\n\n        return {\n          content: [{ text: `Error: ${error}`, type: \"text\" }],\n          isError: true,\n        };\n      }\n\n      return result;\n    });\n  }\n}\n\nconst FastMCPEventEmitterBase: {\n  new (): StrictEventEmitter<EventEmitter, FastMCPEvents<FastMCPSessionAuth>>;\n} = EventEmitter;\n\ntype Authenticate<T> = (request: http.IncomingMessage) => Promise<T>;\n\nclass FastMCPEventEmitter extends FastMCPEventEmitterBase {}\n\nexport class FastMCP<\n  T extends Record<string, unknown> | undefined = undefined,\n> extends FastMCPEventEmitter {\n  public get sessions(): FastMCPSession<T>[] {\n    return this.#sessions;\n  }\n  #authenticate: Authenticate<T> | undefined;\n  #httpStreamServer: null | SSEServer = null;\n  #options: ServerOptions<T>;\n  #prompts: InputPrompt[] = [];\n  #resources: Resource[] = [];\n  #resourcesTemplates: InputResourceTemplate[] = [];\n  #sessions: FastMCPSession<T>[] = [];\n\n  #tools: Tool<T>[] = [];\n\n  constructor(public options: ServerOptions<T>) {\n    super();\n\n    this.#options = options;\n    this.#authenticate = options.authenticate;\n  }\n\n  /**\n   * Adds a prompt to the server.\n   */\n  public addPrompt<const Args extends InputPromptArgument[]>(\n    prompt: InputPrompt<Args>,\n  ) {\n    this.#prompts.push(prompt);\n  }\n\n  /**\n   * Adds a resource to the server.\n   */\n  public addResource(resource: Resource) {\n    this.#resources.push(resource);\n  }\n\n  /**\n   * Adds a resource template to the server.\n   */\n  public addResourceTemplate<\n    const Args extends InputResourceTemplateArgument[],\n  >(resource: InputResourceTemplate<Args>) {\n    this.#resourcesTemplates.push(resource);\n  }\n\n  /**\n   * Adds a tool to the server.\n   */\n  public addTool<Params extends ToolParameters>(tool: Tool<T, Params>) {\n    this.#tools.push(tool as unknown as Tool<T>);\n  }\n\n  /**\n   * Starts the server.\n   */\n  public async start(\n    options:\n      | {\n          httpStream: { port: number };\n          transportType: \"httpStream\";\n        }\n      | { transportType: \"stdio\" } = {\n      transportType: \"stdio\",\n    },\n  ) {\n    if (options.transportType === \"stdio\") {\n      const transport = new StdioServerTransport();\n\n      const session = new FastMCPSession<T>({\n        instructions: this.#options.instructions,\n        name: this.#options.name,\n        ping: this.#options.ping,\n        prompts: this.#prompts,\n        resources: this.#resources,\n        resourcesTemplates: this.#resourcesTemplates,\n        roots: this.#options.roots,\n        tools: this.#tools,\n        version: this.#options.version,\n      });\n\n      await session.connect(transport);\n\n      this.#sessions.push(session);\n\n      this.emit(\"connect\", {\n        session,\n      });\n    } else if (options.transportType === \"httpStream\") {\n      this.#httpStreamServer = await startHTTPServer<FastMCPSession<T>>({\n        createServer: async (request) => {\n          let auth: T | undefined;\n\n          if (this.#authenticate) {\n            auth = await this.#authenticate(request);\n          }\n\n          return new FastMCPSession<T>({\n            auth,\n            instructions: this.#options.instructions,\n            name: this.#options.name,\n            ping: this.#options.ping,\n            prompts: this.#prompts,\n            resources: this.#resources,\n            resourcesTemplates: this.#resourcesTemplates,\n            roots: this.#options.roots,\n            tools: this.#tools,\n            version: this.#options.version,\n          });\n        },\n        onClose: (session) => {\n          this.emit(\"disconnect\", {\n            session,\n          });\n        },\n        onConnect: async (session) => {\n          this.#sessions.push(session);\n\n          this.emit(\"connect\", {\n            session,\n          });\n        },\n        onUnhandledRequest: async (req, res) => {\n          const healthConfig = this.#options.health ?? {};\n\n          const enabled =\n            healthConfig.enabled === undefined ? true : healthConfig.enabled;\n\n          if (enabled) {\n            const path = healthConfig.path ?? \"/health\";\n\n            try {\n              if (\n                req.method === \"GET\" &&\n                new URL(req.url || \"\", \"http://localhost\").pathname === path\n              ) {\n                res\n                  .writeHead(healthConfig.status ?? 200, {\n                    \"Content-Type\": \"text/plain\",\n                  })\n                  .end(healthConfig.message ?? \"ok\");\n\n                return;\n              }\n            } catch (error) {\n              console.error(\"[FastMCP error] health endpoint error\", error);\n            }\n          }\n\n          // If the request was not handled above, return 404\n          res.writeHead(404).end();\n        },\n        port: options.httpStream.port,\n      });\n\n      console.info(\n        `[FastMCP info] server is running on HTTP Stream at http://localhost:${options.httpStream.port}/stream`,\n      );\n    } else {\n      throw new Error(\"Invalid transport type\");\n    }\n  }\n\n  /**\n   * Stops the server.\n   */\n  public async stop() {\n    if (this.#httpStreamServer) {\n      await this.#httpStreamServer.close();\n    }\n  }\n}\n\nexport type { Context };\nexport type { Tool, ToolParameters };\nexport type { Content, ContentResult, ImageContent, TextContent };\nexport type { Progress, SerializableValue };\nexport type { Resource, ResourceResult };\nexport type { ResourceTemplate, ResourceTemplateArgument };\nexport type { Prompt, PromptArgument };\nexport type { InputPrompt, InputPromptArgument };\nexport type { LoggingLevel, ServerOptions };\nexport type { FastMCPEvents, FastMCPSessionEvents };\n"]}